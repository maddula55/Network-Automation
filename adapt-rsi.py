#!/usr/bin/env python3
"""
Adapt-RSI is a script to extract configuration from a file containing junos RSI output 
and adapt the configuration to use it in a lab device. 
Script will extract the config from RSI and remove config elements that might affect 
the connectivity to the device. Based on the no. of FPCs in target lab device, script 
will remove invalid fpc configuration and modify invalid interface names with dummy interface names.
"""
import time
from pprint import pprint
import sys
if sys.version_info < (3, 4):
    raise RuntimeError("This package requires Python 3.4+")
import warnings
import jnpr.junos
from jnpr.junos import Device
from jnpr.junos.utils.sw import SW
from jnpr.junos.exception import ConnectError
from jnpr.junos.exception import ConnectAuthError
from jnpr.junos.exception import ConnectTimeoutError
import re
from lxml import etree
from jnpr.junos.utils.config import Config
from jnpr.junos.exception import LockError
from datetime import datetime
from jnpr.junos.utils.start_shell import StartShell
import argparse
import yaml
import subprocess
from pathlib import Path
if not sys.warnoptions:
    warnings.simplefilter("ignore")

script_version="v1.1.0"

fpc_slots_in_chassis = {}
skip_hierarchy_list = []
skip_statement_list = []
junos_image_location_map = {}
hw_compatibility_map = {}
junos_image_name_format_map = {}
junos_image_name_format_selector = {}
split_copy_path = ""
source_model = "MX2020"
target_model = "MX80"
baseline_groups = []
credentials_list = []
fqdn_regex = ""
fqdn_suffix = ""

def set_personality(config):
    if Path(config).is_file():
        with open(config, 'r') as yaml_file:
            config = yaml.load(yaml_file)
            global fpc_slots_in_chassis
            global skip_hierarchy_list
            global junos_image_location_map
            global hw_compatibility_map
            global junos_image_name_format_map
            global junos_image_name_format_selector
            global split_copy_path
            global skip_statement_list
            global baseline_groups
            global credentials_list
            global fqdn_regex
            global fqdn_suffix
            fpc_slots_in_chassis = config['fpc_slots_in_chassis']
            skip_hierarchy_list = config['skip_hierarchy_list']
            skip_statement_list = config['skip_statement_list']
            junos_image_name_format_selector = config['junos_image_name_format_selector']
            junos_image_name_format_map = config['junos_image_name_format_map']
            junos_image_location_map = config['junos_image_location_map']
            hw_compatibility_map = config['hw_compatibility_map']
            split_copy_path = config['split_copy_path']
            baseline_groups = config['baseline_groups']
            credentials_list = config['credentials_list']
            fqdn_regex = config['fqdn_regex']
            fqdn_suffix = config['fqdn_suffix']

    else:
        print("Config file for this script ",args.config," is not available. Script will now exit")
        sys.exit(1)

def extract_modify_and_generate_config (router,rsi_file):
    
    # Step 1: Extract config from RSI

    with open(rsi_file) as input_data:
        with open('temp_config_from_rsi.config','w') as router_config:
            comment_string="/* Configuration generated by adapt-rsi.py "+script_version+" using RSI output in "+rsi_file+" */"
            router_config.write(comment_string)
            rsi_validator = 0
            for line in input_data:
                if 'show configuration | except SECRET-DATA | display omit' in line.strip():
                    rsi_validator = rsi_validator + 1
                    break
            more_pattern_to_be_removed = re.compile(r'^(.*)---\(more\)---(.*)$')
            windows_line_ending_to_be_removed = re.compile(r'\^M')
            for line in input_data:
                if 'show interfaces extensive no-forwarding' in line.strip():
                    rsi_validator = rsi_validator + 1
                    break
                if more_pattern_to_be_removed.match(line):
                    line = more_pattern_to_be_removed.sub(r"\g<1>"+r"\g<2>",line)
                if windows_line_ending_to_be_removed.match(line):
                    line = windows_line_ending_to_be_removed.sub("",line)
                router_config.write(line)

    if rsi_validator != 2:
        print(rsi_file," is not a valid RSI file. Script will exit now. \n")
        sys.exit(1)

    #Step 2: Delete unwanted config

    with open('temp_config_from_rsi.config') as input_data:

        with open('config_from_rsi.config','w') as router_config:
            line = input_data.readline()
            line_number = 1
            current_hierarchy = []
            start_hierarchy_pattern = re.compile('^\s*(.*)\{\s*#?.*$')
            end_hierarchy_pattern = re.compile('^\s*\}\s*')
            statement_end_pattern = re.compile('^.*;\s*#?.*$')
            annotation_pattern = re.compile('^\s*\/\*.*\*\/\s*$')
            annotation_start_pattern = re.compile(r'^\s*/\*.*$')
            annotation_end_pattern = re.compile(r'^.*\*/\s*$')
            description_pattern = re.compile('^\s*description.*;\s*$')
            while line:

                skip_hierarchy = False
                skip_current_line = False

                if annotation_start_pattern.match(line):  ## Skip processing single and multi line annotations and write it directly to config file.
                    while not (annotation_end_pattern.match(line)):
                        router_config.write(line)
                        line = input_data.readline()
                        line_number+=1
                    router_config.write(line)
                    skip_current_line = True

                if start_hierarchy_pattern.match(line) and not skip_current_line:
                    current_hierarchy.append(str(start_hierarchy_pattern.search(line).group(1)).strip())
                    
                    '''
                     The list current_hierarchy has elements corresponding to the current config hierarchy that the line that is being
                     parsed belongs to. Eg: if the current line being parsed is under [edit interfaces ge-0/0/0 unit 0 family inet]
                     list will have entries [interfaces, ge-0/0/0, unit 0, family inet]
                     The following for loop checks if the current hierarchy is part of the skip_hierarchy_list in script configuration yaml file
                     if so, the hierarchy is marked to be skipped
                    '''

                    for skip_hierarchy_item in skip_hierarchy_list: 
                        list_of_items = (str(skip_hierarchy_item)).split(sep='\\')
                        if len(list_of_items) == len(current_hierarchy):
                            for index in range(0,len(list_of_items)):
                                if not ("<*>" in list_of_items[index].strip()):
                                    if (current_hierarchy[index].strip().startswith(list_of_items[index].strip())):
                                        skip_hierarchy = True
                                    else:
                                        skip_hierarchy = False
                                        break
                        if skip_hierarchy:
                            print ("Ignoring configuration hierarchy starting at line#"+str(line_number)+": ","[edit "+' '.join(current_hierarchy)+"]")
                            break

                if end_hierarchy_pattern.match(line) and not skip_current_line:
                    current_hierarchy.pop() # current config hierarchy is closed, delete the last element in hierarchy list

                '''
                skip hierarchy is marked true based on entries in skip_hierarchy_list in script configuration yaml file. Ignore the config lines under current hierarchy
                increment hierarchy counter value by 1 when seeing hierarchy open '{' and decrement hierarchy counter value by 1 when seeing hierarchy close '}'
                continue reading lines from rsi without writing it to config until hierarchy counter value becomes 0, which would mean the entire hierarchy is skipped
                '''
                if skip_hierarchy:
                    hierarchy_counter=1
                    while hierarchy_counter > 0:
                        next_line = input_data.readline()
                        line_number+=1
                        if end_hierarchy_pattern.match(next_line):
                            hierarchy_counter = hierarchy_counter-1
                        if start_hierarchy_pattern.match(next_line):
                            hierarchy_counter = hierarchy_counter + 1
                    skip_current_line = True
                    current_hierarchy.pop()
                
                

                if (not skip_current_line) and not (start_hierarchy_pattern.match(line) or end_hierarchy_pattern.match(line) or statement_end_pattern.match(line)):
                    skip_current_line = True


                if not skip_current_line:
                    if (not description_pattern.match(line)) and (not start_hierarchy_pattern.match(line)) and (not end_hierarchy_pattern.match(line)) and (statement_end_pattern.match(line)):
                        '''
                         The following for loop checks if the current line is part of the skip_statement_list in script configuration yaml file
                         if so, the line is marked to be skipped from being written to configuration file
                        '''
                        for skip_statement in skip_statement_list:
                            hierarchies_match = False
                            list_of_items = (str(skip_statement)).split(sep='\\')
                            if len(list_of_items)-1 == len(current_hierarchy):
                                for index in range(0,len(list_of_items)-1):
                                    if not ("<*>" in list_of_items[index].strip()):
                                        if (current_hierarchy[index].strip().startswith(list_of_items[index].strip())):
                                            hierarchies_match = True
                                        else:
                                            hierarchies_match = False
                                            break
                            if hierarchies_match:
                                if line.strip().startswith(list_of_items[len(list_of_items)-1].strip()):
                                    print ("Ignoring configuration statement at line#"+str(line_number)+": ","set "+' '.join(current_hierarchy)+" "+line.strip())
                                    skip_current_line = True
                                    break
                    if not skip_current_line:
                        router_config.write(line)
                
                line = input_data.readline()
                line_number+=1

    # Step 3: Based on no. of FPCs supported in the target device, delete invalid fpc config and replace invalid interfaces with dummy interface names
    '''
    Example: if we are applying config from MX960 to MX240. Config from MX960 may have interface names having fpc number between 0-11 and can have
    fpc configuration under [edit chassis] having fpc number between 0-11. On MX240, only values 0-2 are valid and router will consider the config invalid if
    any other fpc number in interface name or fpc config under [edit chassis]. Rename such interfaces with a dummy interface name. if the first interface with invalid
    fpc number is ge-3/0/1, rename it to ge-0/0/50. For every subsequent invalid interface, increment the interface number (51,52,etc.) until the number becomes 126 which
    is the last valid interface number in junos. After that, increment pic number and reset interface number to 50 (ge-0/1/50).

    We cannot follow the above logic for tunnel interfaces (lt/vt/gr) as tunnel interfaces have last valid interface value of 46. Use interface name 0/0/20 to 0/0/46 and then
    increment pic number if there are more such interfaces to be renamed.

    if config for invalid fpc is found under [edit chassis], do not write the config to file.
    '''
    source_model = "MX2020"
    with open(rsi_file) as input_data:
        for line in input_data:
                if 'show version detail no-forwarding' in line.strip():
                    break

        for line in input_data:
                if 'Model' in line.strip():
                    pattern = re.compile("^\s*Model:\s*(\S*)\s*$")
                    if pattern.match(line):
                        source_model = (re.search("^\s*Model:\s*(\S*)\s*$",line).group(1)).upper()
                        break

    print ("\n\nDevice Model in RSI: ",source_model)
    router.open()
    target_model = str((router.facts)['model']).upper()
    router.close()
    print ("Model of device on which config has to be loaded: ",target_model)
    
    slots_in_chassis = 1
    slots_in_source_chassis = 20
    if not (source_model.strip()==target_model.strip()):
        try:
            slots_in_chassis = fpc_slots_in_chassis[target_model.strip()]
        except:
            print ("Could not get no. of FPC slots in target device from script configuration. Will use a default value of 0")
        
        try:
            slots_in_source_chassis = fpc_slots_in_chassis[source_model.strip()]
        except:
            print ("Could not get no. of FPC slots for device in RSI from script configuration. Will use a default value of 20")
    
        if (slots_in_source_chassis > slots_in_chassis) and (not(target_model.strip()==source_model.strip())):
            print ("No. of slots in RSI greater than target device...script will remove invalid fpc config and replacing invalid interfaces with dummy interface names")
    
    ## need to remove the following unnecessary parsing when source and target model are same or when slots in tartget and source model are same
    
    interface_counter = 50
    pic_counter = 0
    tunnel_pic_counter = 0
    tunnel_interface_counter = 20
    already_seen_interface={}
    with open('config_from_rsi.config') as input_data:
        with open('final_config_from_rsi.config','w') as router_config:
            interface_pattern = re.compile("^(.*)(\w{2}-)(\d{1,2})\/(\d*)\/(\d*)(.*[;{].*)$")
            interface_description_pattern = re.compile("^(.*)(description )(.*)(\w{2})(-)(\d*)(\/)(\d*)(\/)(\d*)(.*)$")
            actual_interface_pattern = re.compile("^(.*)(\w{2}-\d*\/\d*\/\d*)(.*[;{].*)$")
            chassis_fpc_config_pattern = re.compile("^.*fpc\s{1,}(\d{1,}).*{.*$")
            for line in input_data:
                if interface_pattern.match(line):
                    if not interface_description_pattern.match(line):
                        #print ("\nline being evaluated by interface name change code\n",line)
                        fpc_slot_number = int(interface_pattern.search(line).group(3))
                        if (fpc_slot_number > slots_in_chassis-1) and (not(target_model.strip()==source_model.strip())):
                            interface_in_question = actual_interface_pattern.search(line).group(2)
                            if interface_in_question.strip() in already_seen_interface.keys():
                                #print ("\noriginal line: ",line)
                                replaced_line = interface_pattern.sub(r"\g<1>"+already_seen_interface[interface_in_question].strip()+r"\g<6>",line)
                                #print ("\nreplaced line: ",replaced_line)
                                router_config.write(replaced_line)
                            else:
                                #print ("\noriginal line: ",line)
                                if ('lt' in interface_pattern.search(line).group(2)) or ('vt' in interface_pattern.search(line).group(2)) or ('gr' in interface_pattern.search(line).group(2)):
                                    replaced_line = interface_pattern.sub(r"\g<1>\g<2>"+"0/"+str(tunnel_pic_counter)+"/"+str(tunnel_interface_counter)+r"\g<6>",line)
                                    #print ("\nreplaced line: ",replaced_line)
                                    already_seen_interface[interface_in_question]= interface_pattern.sub(r"\g<2>"+"0/"+str(tunnel_pic_counter)+"/"+str(tunnel_interface_counter),line).strip()
                                    router_config.write(replaced_line)
                                else:
                                    replaced_line = interface_pattern.sub(r"\g<1>\g<2>"+"0/"+str(pic_counter)+"/"+str(interface_counter)+r"\g<6>",line)
                                    #print ("\nreplaced line: ",replaced_line)
                                    already_seen_interface[interface_in_question]= interface_pattern.sub(r"\g<2>"+"0/"+str(pic_counter)+"/"+str(interface_counter),line).strip()
                                    router_config.write(replaced_line)
                                if interface_counter < 127:
                                    interface_counter = interface_counter + 1
                                else:
                                    interface_counter = 50
                                    pic_counter=pic_counter+1
                                if tunnel_interface_counter < 47:
                                    tunnel_interface_counter = tunnel_interface_counter + 1
                                else:
                                    tunnel_interface_counter = 20
                                    tunnel_pic_counter = tunnel_pic_counter + 1
                        else:
                            router_config.write(line)
                    else:
                            router_config.write(line)
                elif chassis_fpc_config_pattern.match(line):
                    fpc_slot_number = int(chassis_fpc_config_pattern.search(line).group(1))
                    if fpc_slot_number > slots_in_chassis-1:
                        hierarchy_counter=1
                        while hierarchy_counter > 0:
                            next_line = input_data.readline()
                            if '}' in next_line:
                                hierarchy_counter = hierarchy_counter-1
                            if '{' in next_line:
                                hierarchy_counter = hierarchy_counter + 1
                    else:
                        router_config.write(line)

                else:
                    router_config.write(line)

################################################################
# Start of Experimental code to parse Amazon scrubbed RSI file #
################################################################


def extract_modify_and_generate_config_for_amazon (router,rsi_file):
    
    # Step 1: Extract config from RSI

    print ("Starting to parse RSI file... Script assumes that the file is scrubbed by Amazon.\n")
    with open(rsi_file) as input_data:
        with open('temp_config_from_rsi.config','w') as router_config:
            comment_string="/* Configuration generated by adapt-rsi.py "+script_version+" using RSI output in "+rsi_file+" */\n"
            router_config.write(comment_string)
            rsi_validator = 0
            for line in input_data:
                if re.match(r'^version.*;\s*$',line) or ('## Last commit:' in line):
                    rsi_validator = rsi_validator + 1
                    break

            more_pattern_to_be_removed = re.compile(r'^(.*)---\(more\)---(.*)$')
            windows_line_ending_to_be_removed = re.compile(r'\^M')
            for line in input_data:
                if 'show interfaces extensive no-forwarding' in line.strip():
                    rsi_validator = rsi_validator + 1
                    break
                if more_pattern_to_be_removed.match(line):
                    line = more_pattern_to_be_removed.sub(r"\g<1>"+r"\g<2>",line)
                if windows_line_ending_to_be_removed.match(line):
                    line = windows_line_ending_to_be_removed.sub("",line)
                router_config.write(line)

    if rsi_validator != 2:
        print(rsi_file," is not a valid RSI file. Script will exit now. \n")
        sys.exit(1)

    #Step 2: Delete unwanted config

    with open('temp_config_from_rsi.config') as input_data:

        with open('config_from_rsi.config','w') as router_config:
            line = input_data.readline()
            line_number = 1
            current_hierarchy = []
            start_hierarchy_pattern = re.compile('^\s*(.*)\{\s*#?.*$')
            annotation_pattern = re.compile('^\s*/\*$')
            annotation_start_pattern = re.compile(r'^\s*/\*.*$')
            annotation_end_pattern = re.compile(r'^.*\*/\s*$')
            end_hierarchy_pattern = re.compile('^(\s*)\}\s*')
            count_space_at_the_start_pattern = re.compile('^(\s*)\S*.*$')
            statement_end_pattern = re.compile('^.*;\s*#?.*$')
            description_pattern = re.compile('^\s*description.*;\s*$')
            previous_line_was_start_hierarchy = False
            previous_line_was_statement = False
            spaces_at_the_start_of_last_line = 0
            previous_line_written_was_start_hierarchy = False
            while line:

                skip_hierarchy = False
                skip_current_line = False

                if annotation_start_pattern.match(line):  ## Skip processing single and multi line annotations and write it directly to config file.
                    while not (annotation_end_pattern.match(line)):
                        router_config.write(line)
                        line = input_data.readline()
                        line_number+=1
                    router_config.write(line)
                    skip_current_line = True

                if start_hierarchy_pattern.match(line) and not (((len(count_space_at_the_start_pattern.search(line).group(1))>spaces_at_the_start_of_last_line) and not previous_line_was_start_hierarchy)) and not skip_current_line:
                    current_hierarchy.append(str(start_hierarchy_pattern.search(line).group(1)).strip())
                    '''
                     The list current_hierarchy has elements corresponding to the current config hierarchy that the line that is being
                     parsed belongs to. Eg: if the current line being parsed is under [edit interfaces ge-0/0/0 unit 0 family inet]
                     list will have entries [interfaces, ge-0/0/0, unit 0, family inet]
                     The following for loop checks if the current hierarchy is part of the skip_hierarchy_list in script configuration yaml file
                     if so, the hierarchy is marked to be skipped
                    '''
                    for skip_hierarchy_item in skip_hierarchy_list:
                        list_of_items = (str(skip_hierarchy_item)).split(sep='\\')
                        if len(list_of_items) == len(current_hierarchy):
                            for index in range(0,len(list_of_items)):
                                if not ("<*>" in list_of_items[index].strip()):
                                    if (current_hierarchy[index].strip().startswith(list_of_items[index].strip())):
                                        skip_hierarchy = True
                                    else:
                                        skip_hierarchy = False
                                        break
                        if skip_hierarchy:
                            print ("Ignoring configuration hierarchy starting at line#"+str(line_number)+": ","[edit "+' '.join(current_hierarchy)+"]")
                            break
                
                '''
                If current line is hierarchy close, i.e., '}':
                1. ensure that spaces seen at the start, before the character '}', is less than the spaces seen at the start of previous line
                2. if previous line was opening a hierarchy, the spaces at the start of the previous line and current line should match.
                Only if 1&2 are true, this line should be considered as a valid hierarchy close character and last element in current hierarchy list should be removed.

                Otherwise, it would mean that there is no corresponding hierarchy open character ('{') for the hierarchy close character in current line which is seen
                when config is scrubbed to remove sensitive information, which might include a line that has hierarchy open character ('{').
                '''

                if end_hierarchy_pattern.match(line) and not skip_current_line:
                    if (len(end_hierarchy_pattern.search(line).group(1))<spaces_at_the_start_of_last_line) or ((previous_line_was_start_hierarchy or previous_line_written_was_start_hierarchy) and len(end_hierarchy_pattern.search(line).group(1))==spaces_at_the_start_of_last_line):
                        current_hierarchy.pop() 
                    else:
                        skip_current_line = True
                        print("Ignoring Line#"+str(line_number)+" as the hierarchy close character do not have a corresponding heirarchy open character.")

                '''
                skip hierarchy is marked true based on entries in skip_hierarchy_list in script configuration yaml file. Ignore the config lines under current hierarchy
                increment hierarchy counter value by 1 when seeing hierarchy open '{' and decrement hierarchy counter value by 1 when seeing hierarchy close '}'
                continue reading lines from rsi without writing it to config until hierarchy counter value becomes 0, which would mean the entire hierarchy is skipped
                skipping hierarchy is a bit more complicated when the config is scrubbed to remove sensitive information, which would cause hierarchy open statements to be removed
                from the file. Skip hierarchy has to consider this. To account for possible, hierarchy start removal, script will check:
                If current line is hierarchy close, i.e., '}':
                1. ensure that spaces seen at the start, before the character '}', is less than the spaces seen at the start of previous line
                2. if previous line was opening a hierarchy, the spaces at the start of the previous line and current line should match.
                Only if 1&2 are true, this line should be considered as a valid hierarchy close character and hierarchy counter value is decremented by 1
                '''
                if skip_hierarchy:
                    hierarchy_counter=1
                    spaces_at_the_start_of_last_line_local = len(str(count_space_at_the_start_pattern.search(line).group(1)))
                    previous_line_was_start_hierarchy_local = True
                    previous_line_was_statement_local = False
                    while hierarchy_counter > 0:
                        next_line = input_data.readline()
                        line_number+=1
                        if end_hierarchy_pattern.match(next_line):
                            if (len(end_hierarchy_pattern.search(next_line).group(1))<spaces_at_the_start_of_last_line_local) or (previous_line_was_start_hierarchy_local and len(end_hierarchy_pattern.search(next_line).group(1))==spaces_at_the_start_of_last_line_local):
                                hierarchy_counter = hierarchy_counter-1
                                spaces_at_the_start_of_last_line_local = len(str(count_space_at_the_start_pattern.search(next_line).group(1)))
                            previous_line_was_statement_local = False
                            previous_line_was_start_hierarchy_local = False
                        
                        if start_hierarchy_pattern.match(next_line):
                            hierarchy_counter = hierarchy_counter + 1
                            previous_line_was_start_hierarchy_local = True
                            previous_line_was_statement_local = False
                        else:
                            previous_line_was_start_hierarchy_local = False
                            if statement_end_pattern.match(next_line):
                                previous_line_was_statement_local = True
                            else:
                                previous_line_was_statement_local = False
                        
                        if previous_line_was_statement_local or previous_line_was_start_hierarchy_local:        
                            spaces_at_the_start_of_last_line_local = len(str(count_space_at_the_start_pattern.search(next_line).group(1)))
                    
                    skip_current_line = True
                    current_hierarchy.pop()
                
                
                '''
                remove lines that match *****LINE OMITTED***** and XXXXXXXXXX, which are seen when RSI is scrubbed to remove sensitive information.
                These patterns can be moved to a list in script config file for easily adding new patterns to be matched and skipped.
                '''
                if re.match('^\s*\*{5}LINE OMITTED\*{5}\s*$',line):
                    skip_current_line = True
                
                if re.match('^\s*X+\s*$',line):
                    skip_current_line = True

                if (not skip_current_line) and not (start_hierarchy_pattern.match(line) or end_hierarchy_pattern.match(line) or statement_end_pattern.match(line)):
                    if previous_line_was_start_hierarchy:
                        previous_line_was_start_hierarchy = False
                    skip_current_line = True
                    if line.strip() != "":
                        print("Ignoring Line#"+str(line_number)+" as it is not a valid statement, hierarchy start or hierarchy end : ",line.strip())

                '''
                Due to config scrubbing to remove sensitive information, lines with hierarchy start character '{' might be removed. If this happens, the config statements
                under that hierarchy would be invalid and will have to be removed. Number of spaces at the start of current line can be greater than the number of spaces at the 
                start of previous line only if the previous line was opening a config hierarchy. Otherwise, consider this statement to be belonging to an hierarchy which is unrecognized
                and skip writing this line to config.
                '''

                if not skip_current_line and ((len(count_space_at_the_start_pattern.search(line).group(1))>spaces_at_the_start_of_last_line) and not previous_line_was_start_hierarchy):
                    skip_current_line = True
                    if line.strip() != "":
                        print("Ignoring Line#"+str(line_number)+" as the start of the hierarchy for this config statement is not found : ",line.strip())

                if not skip_current_line:
                    if (not description_pattern.match(line)) and (not start_hierarchy_pattern.match(line)) and (not end_hierarchy_pattern.match(line)) and (statement_end_pattern.match(line)):
                        '''
                         The following for loop checks if the current line is part of the skip_statement_list in script configuration yaml file
                         if so, the line is marked to be skipped from being written to configuration file
                        '''
                        for skip_statement in skip_statement_list:
                            hierarchies_match = False
                            list_of_items = (str(skip_statement)).split(sep='\\')
                            if len(list_of_items)-1 == len(current_hierarchy):
                                for index in range(0,len(list_of_items)-1):
                                    if not ("<*>" in list_of_items[index].strip()):
                                        if (current_hierarchy[index].strip().startswith(list_of_items[index].strip())):
                                            hierarchies_match = True
                                        else:
                                            hierarchies_match = False
                                            break
                            if hierarchies_match:
                                if line.strip().startswith(list_of_items[len(list_of_items)-1].strip()):
                                    skip_current_line = True
                                    print ("Ignoring configuration statement at line#"+str(line_number)+": ","set "+' '.join(current_hierarchy)+" "+line.strip())
                                    break
                    if not skip_current_line:
                        spaces_at_the_start_of_last_line = len(str(count_space_at_the_start_pattern.search(line).group(1)))
                        if start_hierarchy_pattern.match(line):
                            previous_line_was_start_hierarchy = True
                            previous_line_written_was_start_hierarchy = True
                            previous_line_was_statement = False
                        elif statement_end_pattern.match(line):
                            previous_line_was_statement = True
                            previous_line_was_start_hierarchy = False
                            previous_line_written_was_start_hierarchy = False
                        else:
                            previous_line_was_statement = False
                            previous_line_was_start_hierarchy = False
                            previous_line_written_was_start_hierarchy = False
                        
                        router_config.write(line)
                
                line = input_data.readline()
                line_number+=1

    # Step 3: Based on no. of FPCs supported in the target device, delete invalid fpc config and replace invalid interfaces with dummy interface names
    
    '''
    Example: if we are applying config from MX960 to MX240. Config from MX960 may have interface names having fpc number between 0-11 and can have
    fpc configuration under [edit chassis] having fpc number between 0-11. On MX240, only values 0-2 are valid and router will consider the config invalid if
    any other fpc number in interface name or fpc config under [edit chassis]. Rename such interfaces with a dummy interface name. if the first interface with invalid
    fpc number is ge-3/0/1, rename it to ge-0/0/50. For every subsequent invalid interface, increment the interface number (51,52,etc.) until the number becomes 126 which
    is the last valid interface number in junos. After that, increment pic number and reset interface number to 50 (ge-0/1/50).

    We cannot follow the above logic for tunnel interfaces (lt/vt/gr) as tunnel interfaces have last valid interface value of 46. Use interface name 0/0/20 to 0/0/46 and then
    increment pic number if there are more such interfaces to be renamed.

    if config for invalid fpc is found under [edit chassis], do not write the config to file.
    '''
    with open(rsi_file) as input_data:
        for line in input_data:
                if 'show version detail no-forwarding' in line.strip():
                    break

        for line in input_data:
                if 'Model' in line.strip():
                    pattern = re.compile("^\s*Model:\s*(\S*)\s*$")
                    if pattern.match(line):
                        source_model = (re.search("^\s*Model:\s*(\S*)\s*$",line).group(1)).upper()
                        break

    print ("\n\nDevice Model in RSI: ",source_model)
    router.open()
    target_model = str((router.facts)['model']).upper()
    router.close()
    print ("Model of device on which config has to be loaded: ",target_model)
    
    slots_in_chassis = 1
    slots_in_source_chassis = 20

    try:
        slots_in_chassis = fpc_slots_in_chassis[target_model.strip()]
    except:
        print ("Could not get no. of FPC slots in target device from script configuration. Will use a default value of 0")
    
    try:
        slots_in_source_chassis = fpc_slots_in_chassis[source_model.strip()]
    except:
        print ("Could not get no. of FPC slots for device in RSI from script configuration. Will use a default value of 20")

    if (slots_in_source_chassis > slots_in_chassis):
        print ("No. of slots in RSI greater than target device...script will remove invalid fpc config and replacing invalid interfaces with dummy interface names")
    
    interface_counter = 50
    pic_counter = 0
    tunnel_pic_counter = 0
    tunnel_interface_counter = 20
    already_seen_interface={}
    with open('config_from_rsi.config') as input_data:
        with open('final_config_from_rsi.config','w') as router_config:
            interface_pattern = re.compile("^(.*)(\w{2}-)(\d{1,2})\/(\d*)\/(\d*)(.*[;{].*)$")
            interface_description_pattern = re.compile("^(.*)(description )(.*)(\w{2})(-)(\d*)(\/)(\d*)(\/)(\d*)(.*)$")
            actual_interface_pattern = re.compile("^(.*)(\w{2}-\d*\/\d*\/\d*)(.*[;{].*)$")
            chassis_fpc_config_pattern = re.compile("^.*fpc\s{1,}(\d{1,}).*{.*$")
            for line in input_data:
                if interface_pattern.match(line):
                    if not interface_description_pattern.match(line):
                        #print ("\nline being evaluated by interface name change code\n",line)
                        fpc_slot_number = int(interface_pattern.search(line).group(3))
                        if fpc_slot_number > slots_in_chassis-1:
                            interface_in_question = actual_interface_pattern.search(line).group(2)
                            if interface_in_question.strip() in already_seen_interface.keys():
                                #print ("\noriginal line: ",line)
                                replaced_line = interface_pattern.sub(r"\g<1>"+already_seen_interface[interface_in_question].strip()+r"\g<6>",line)
                                #print ("\nreplaced line: ",replaced_line)
                                router_config.write(replaced_line)
                            else:
                                #print ("\noriginal line: ",line)
                                if ('lt' in interface_pattern.search(line).group(2)) or ('vt' in interface_pattern.search(line).group(2)) or ('gr' in interface_pattern.search(line).group(2)):
                                    replaced_line = interface_pattern.sub(r"\g<1>\g<2>"+"0/"+str(tunnel_pic_counter)+"/"+str(tunnel_interface_counter)+r"\g<6>",line)
                                    #print ("\nreplaced line: ",replaced_line)
                                    already_seen_interface[interface_in_question]= interface_pattern.sub(r"\g<2>"+"0/"+str(tunnel_pic_counter)+"/"+str(tunnel_interface_counter),line).strip()
                                    router_config.write(replaced_line)
                                else:
                                    replaced_line = interface_pattern.sub(r"\g<1>\g<2>"+"0/"+str(pic_counter)+"/"+str(interface_counter)+r"\g<6>",line)
                                    #print ("\nreplaced line: ",replaced_line)
                                    already_seen_interface[interface_in_question]= interface_pattern.sub(r"\g<2>"+"0/"+str(pic_counter)+"/"+str(interface_counter),line).strip()
                                    router_config.write(replaced_line)
                                if interface_counter < 127:
                                    interface_counter = interface_counter + 1
                                else:
                                    interface_counter = 50
                                    pic_counter=pic_counter+1
                                if tunnel_interface_counter < 47:
                                    tunnel_interface_counter = tunnel_interface_counter + 1
                                else:
                                    tunnel_interface_counter = 20
                                    tunnel_pic_counter = tunnel_pic_counter + 1
                        else:
                            router_config.write(line)
                    else:
                            router_config.write(line)
                elif chassis_fpc_config_pattern.match(line):
                    fpc_slot_number = int(chassis_fpc_config_pattern.search(line).group(1))
                    if fpc_slot_number > slots_in_chassis-1:
                        hierarchy_counter=1
                        while hierarchy_counter > 0:
                            next_line = input_data.readline()
                            if '}' in next_line:
                                hierarchy_counter = hierarchy_counter-1
                            if '{' in next_line:
                                hierarchy_counter = hierarchy_counter + 1
                    else:
                        router_config.write(line)

                else:
                    router_config.write(line)

##############################################################
# End of Experimental code to parse Amazon scrubbed RSI file #
##############################################################



def load_baseline_config(router,router_name):
    
    shellSession = StartShell(router)
    shellSession.open()
    with open('baseline_from_router.set','w') as base_config:
        for group in baseline_groups:
            shell_output = shellSession.run ('cli -c "show configuration groups '+group+'| display set| no-more"')
            config = (shell_output[1].split('\n'))[1:-1] #Use second element of shell_ouput list. Remove first and last line. First line is the command executed and last line is cli prompt.
            if len(config) > 0:
                for config_command in config:
                    base_config.write(config_command)
                base_config.write('set apply-groups '+group+'\n')
        base_config.write(' set system services netconf ssh'+'\n')
    shellSession.close()
    
    router.open()
    facts = dict((router.facts))
    syncrhonize = False

    if 're0' in list(facts['current_re']):
        
        if facts['RE1']:
            if (str(facts['RE1']['status']) == 'OK'):
                syncrhonize = True

    elif 're1' in list(facts['current_re']):
        if facts['RE0']:
            if (str(facts['RE0']['status']) == 'OK'):
                syncrhonize = True

    with Config(router) as cu:
        try:
            cu.load('',overwrite=True,format="text",ignore_warning=True)
            cu.load(path='baseline_from_router.set',format="set",ignore_warning=True)
            cu.commit(force_sync=syncrhonize,timeout=360)
            print ("Applied baseline config on ",router_name, "\n")
            router.close()
            return 0
        except Exception as e:
            print(str(e))
            print ("\n\nFailed to load basedline config to ",router_name,"\n\n")
            router.close()
            return 1
        

    

def load_generated_config(router,router_name,no_commit_confirm):
    router.open()
    with Config(router) as cu:
        try:
            cu.load(path="final_config_from_rsi.config",format="text",merge=True,ignore_warning=True)
            static_route_config = router.rpc.get_config(filter_xml='routing-options/static')
            if 'static' in etree.tostring(static_route_config, encoding='unicode'):
                if '0.0.0.0/0' in etree.tostring(static_route_config, encoding='unicode'):
                    cu.load('delete routing-options static route 0.0.0.0/0', format='set',ignore_warning=True)
                    print ("\nDeleted static route for 0/0 from [edit routing-options static] hierarchy to avoid loss of connectivity to ",router_name,"\n")

            if no_commit_confirm:
                cu.commit(timeout=360)
                print ("Applied config from rsi on ",router_name," and performed commit.\n")
            else:
                cu.commit(confirm=10,timeout=360)
                print ("Applied config from rsi on ",router_name," and performed commit. Login to the device and confirm the commit to avoid config rollback to baseline.\n")
            
            router.close()  
            return 0

        except Exception as e:
            print(str(e))
            print ("\n\nif you see a commit error, script might have missed deleting some invalid config.\nConfig generated by the script is applied to ",router_name,"\nTry to deactivate the config reported as invalid and attempt a commit.\n\n")
            router.close()
            return 1
        
def custom_sleep(sleep_time):
    print ("\nSleeping for",sleep_time ,"seconds...")
    t=0
    while(t<sleep_time):
        print(t+1, end=" ", flush=True)
        time.sleep(1)
        t=t+1

def wait_for_router_online(router,sleep_time):
    
    while (1):
        custom_sleep(sleep_time)
        try:
            router.open()
        except:
            print("Couldn't connect to device after reboot. Script will sleep again to retry later.")
            print("You can stop the script with ctrl+c and run this script without --upgrade option to apply RSI config after device is online with new junos version.")
        if router.connected:
            router.close()
            return 0

def do_junos_upgrade (router,cleanfsflag,device_address,device_username,device_password,junos_version_for_upgrade,current_re_only,copy_only):
    
    router.open()
    facts = dict((router.facts))
    router.close()
    current_re_model = None

    if str(facts['version']).strip('-EVO') == str(junos_version_for_upgrade):
        print(device_address,"already is running on junos version",junos_version_for_upgrade)
        return 0

    if 're0' in list(facts['current_re']):
        if dict(facts['RE0'])['model']:
            current_re_model = dict(facts['RE0'])['model']
        else:
            print("Script could not fetch Model of RE0 from",device_address,"which is the current RE. Script will not upgrade",device_address,"\n")
            return 1
        if not current_re_only:
            if facts['RE1']:
                if (str(facts['RE1']['model']) != str(current_re_model)):
                    current_re_only = True
                    print("Script is logged in to RE0 of",device_address,"Either the script could not fetch the RE type of RE1 or the RE type of RE0 does not match RE1. Script will only upgrade RE0 on",device_address,"\n")
                if (not current_re_only) and (str(facts['RE1']['status']) != 'OK'):
                    current_re_only = True
                    print("Script is logged in to RE0 of",device_address,"Status of RE1 is not \'OK\'. Script will only upgrade RE0 on",device_address,"\n")
                if (not current_re_only) and facts['version_RE1']:
                    if str(facts['version_RE1']).strip('-EVO') == junos_version_for_upgrade:
                        current_re_only = True
                        print("Script is logged in to RE0 of",device_address,"RE1 is already running junos version",junos_version_for_upgrade,"Script will only upgrade RE0 on",device_address,"\n")
                else:
                    current_re_only = True
                    print("Script is logged in to RE0 of",device_address,"Script could not fetch version info from RE1. Script will only upgrade RE0 on",device_address,"\n")
    
            else:
                current_re_only = True
                print("Script is logged in to RE0 of",device_address,"Script could not fetch RE1 info. Script will only upgrade RE0 on",device_address,"\n")

    elif 're1' in list(facts['current_re']):
        if dict(facts['RE1'])['model']:
            current_re_model = dict(facts['RE1'])['model']
        else:
            print("Script could not fetch Model of RE1 from",device_address,"which is the current RE. Script will not upgrade",device_address,"\n")
            return 1
        if not current_re_only:
            if facts['RE0']:
                if (str(facts['RE0']['model']) != str(current_re_model)):
                    current_re_only = True
                    print("Script is logged in to RE1 of",device_address,"Either the script could not fetch the RE type of RE0 or the RE type of RE0 does not match RE1. Script will only upgrade RE1 on",device_address,"\n")
                if (not current_re_only) and (str(facts['RE0']['status']) != 'OK'):
                    current_re_only = True
                    print("Script is logged in to RE1 of",device_address,"Status of RE0 is not \'OK\'. Script will only upgrade RE1 on",device_address,"\n")
                if (not current_re_only) and facts['version_RE0']:
                    if str(facts['version_RE0']).strip('-EVO') == junos_version_for_upgrade:
                        current_re_only = True
                        print("Script is logged in to RE1 of",device_address,"RE0 is already running junos version",junos_version_for_upgrade,"Script will only upgrade RE1 on",device_address,"\n")
                else:
                    if (not current_re_only):
                        current_re_only = True
                        print("Script is logged in to RE1 of",device_address,"Script could not fetch version info from RE0. Script will only upgrade RE1 on",device_address,"\n")
    
            else:
                current_re_only = True
                print("Script is logged in to RE1 of",device_address,"Script could not fetch RE0 info. Script will only upgrade RE1 on",device_address,"\n")
    
    else:
        print ("Script could not identify current RE Model. Script will not upgrade",device_address,"\n")
        return 1
    
    if not current_re_model:
        print ("Script could not identify current RE Model. Script will not upgrade",device_address,"\n")
        return 1




    version_year = re.search('^(\d*)\..*$',junos_version_for_upgrade).group(1)
    major_version = re.search('^(\d*\.\d).*$',junos_version_for_upgrade).group(1)
    junos_name_format_type = None
    junos_name_format= None
    junos_image_name = None
    junos_image_location_format = None
    junos_image_path = None
    found_valid_image = False

    for format_map_key in junos_image_name_format_selector.keys():
        if(junos_image_name_format_selector[format_map_key]['from']<=int(version_year)<=junos_image_name_format_selector[format_map_key]['to']):
            junos_name_format_type = format_map_key
    
    if junos_name_format_type is None:
        print("Couldn't fetch Junos name format type. Script will not upgrade",device_address)
        return 1
    
    put_version_in_format = re.compile('^(.*)(VERSION_NUMBER)(.*)$')
    put_version_in_image_location = re.compile('^(.*)(MAJOR_VERSION_NUMBER)(.*)(VERSION_NUMBER)(.*)$')
    put_version_in_image_location_evo = re.compile('^(.*)(VERSION_NUMBER)(.*)$')
    daily_image_format = re.compile('^(\d*\.\d)I\-(\d{8})\.(\d)\.(\d{4})$')
    junos_version_in_directory_path = junos_version_for_upgrade

    if daily_image_format.match(junos_version_for_upgrade): #for daily image
        junos_version_in_directory_path = daily_image_format.search(junos_version_for_upgrade).group(2)+daily_image_format.search(junos_version_for_upgrade).group(4)+'.'+daily_image_format.search(junos_version_for_upgrade).group(3)


    print("Model of current RE in", device_address,"is:",current_re_model)
    
    try:
        junos_name_format = str(junos_image_name_format_map[junos_name_format_type][current_re_model])
        junos_image_name= put_version_in_format.sub(r"\g<1>"+str(junos_version_for_upgrade)+r"\g<3>",junos_name_format)
        junos_image_location_format = junos_image_location_map[current_re_model]

        if 'EVO' in junos_image_name:
            version_without_respin_number = junos_version_for_upgrade
            if re.match('^(.*)\.\d{1,}$',junos_version_for_upgrade):
                version_without_respin_number = str(re.search('^(.*)\.\d{1,}$',junos_version_for_upgrade).group(1))

            try:
                for image_path in list (junos_image_location_format):
                    junos_image_path_pattern = put_version_in_image_location_evo.sub(r"\g<1>"+str(version_without_respin_number)+r"\g<3>",image_path) +"/*/"+ str(junos_image_name)
                    junos_image_paths = glob.glob(junos_image_path_pattern)
                    junos_image_path = ""
                    if len(junos_image_paths) is not 0:
                        junos_image_path = junos_image_paths[0]
                    if(Path(junos_image_path).is_file()):
                        print ("Junos image for upgrading current RE in", device_address, "is at: ",junos_image_path)
                        found_valid_image = True
                        break
            except:
                print("Error in fetching image file location for,",device_address, "from image location format configuration. Please check if correct image location format is available in script configuration file for RE Type: ",current_re_model)
                return 1
        
        else:
            try:
                for image_path in list (junos_image_location_format):
                    junos_image_path = put_version_in_image_location.sub(r"\g<1>"+str(major_version)+r"\g<3>"+str(junos_version_in_directory_path)+r"\g<5>",image_path) + str(junos_image_name)
                    if(Path(junos_image_path).is_file()):
                        print ("Junos image for upgrading current RE in", device_address, "is at: ",junos_image_path)
                        found_valid_image = True
                        break
            except:
                print("Error in fetching image file location for,",device_address, "from image location format configuration. Please check if correct image location format is available in script configuration file for RE Type: ",current_re_model)
                return 1
    except:
        print("Error in fetching image name for",device_address, "based on image name format configuration. Please check if correct image name format is available in script configuration file for RE Type: ",current_re_model)
        return 1
    
    if not found_valid_image or not junos_image_path:
        print("Error in finding suitable junos image to upgrade",device_address, "Script will not upgrade",device_address)
        return 1

    router.open()
    sw = SW(router)
    file_copy_status = 1
    is_vmhost_image = False
    local_checksum_string = None
    remote_checksum_string = None
    checksum_matches = False

    if ('vmhost' in junos_image_path):
        is_vmhost_image = True
    
    print ("Checking whether the device",device_address,"already have the junos image file",junos_image_name,"in /var/tmp/ directory")

    if Path(junos_image_path+'.md5').is_file():
        remote_checksum_string = sw.remote_checksum('/var/tmp/'+junos_image_name,algorithm='md5')
        if remote_checksum_string:
            with open(junos_image_path+'.md5') as checksum_data:
                local_checksum_string = str(checksum_data.readline()).split()[0].rstrip()
            if remote_checksum_string == local_checksum_string:
                checksum_matches = True
    elif Path(junos_image_path+'.sha1').is_file():
        remote_checksum_string = sw.remote_checksum('/var/tmp/'+junos_image_name,algorithm='sha1')
        if remote_checksum_string:
            with open(junos_image_path+'.sha1') as checksum_data:
                local_checksum_string = str(checksum_data.readline()).split()[0].rstrip()
            if remote_checksum_string == local_checksum_string:
                checksum_matches = True
    elif Path(junos_image_path+'.sha256').is_file():
        remote_checksum_string = sw.remote_checksum('/var/tmp/'+junos_image_name,algorithm='sha256')
        if remote_checksum_string:
            with open(junos_image_path+'.sha256') as checksum_data:
                local_checksum_string = str(checksum_data.readline()).split()[0].rstrip()
            if remote_checksum_string == local_checksum_string:
                checksum_matches = True
    else:
        remote_checksum_string = sw.remote_checksum('/var/tmp/'+junos_image_name)
        if remote_checksum_string:
            local_checksum_string = sw.local_checksum(junos_image_path)
            if remote_checksum_string == local_checksum_string:
                checksum_matches = True

    if checksum_matches:
        print ("Device already have the junos image file",junos_image_name,"in /var/tmp/ directory of",device_address,"Script will use this file to perform the upgrade.")
        file_copy_status = 0
    else:
        print ("The device",device_address,"do not have the junos image file",junos_image_name,"in /var/tmp/ directory. Script will copy the required junos image.")
        if Path(str(split_copy_path)).is_file():
            print ("Script will now attempt to use splitcopy.py script to copy",junos_image_path,"to",device_address)
            print("running command:",str(split_copy_path),junos_image_path,device_username+"@"+device_address+":/var/tmp/","--pwd",device_password)
           
            try:
                file_copy_status = subprocess.call([str(split_copy_path),junos_image_path,device_username+"@"+device_address+":/var/tmp/","--pwd",device_password],stdout=sys.stdout,stderr=subprocess.DEVNULL,timeout=900)
            except Exception as e:
                file_copy_status = 1
                print("Attempt to copy the image to", device_address,"using splitcopy utility failed.")
                print(str(e))

            if file_copy_status != 0:
                print ("splitcopy couldn't copy the image to",device_address,"\nScript will use junos pyEZ jnpr.junos.utls.sw.put() to copy image to device. This process will be slower.")
                try:
                    sw.put(junos_image_path,progress=True)
                    file_copy_status = 0
                except Exception as e:
                    print(str(e))
        else:
            print ("Scipt couldnt locate splitcopy utility. Script will use junos pyEZ jnpr.junos.utls.sw.put() to copy image to device. This process will be slower.")
            try:
                sw.put(junos_image_path,progress=True)
                file_copy_status = 0
            except Exception as e:
                print(str(e))


    if file_copy_status != 0:
        print("Script could not copy the required junos image file to current RE of", device_address,"Upgrade will not be performed on",device_address)
        router.close()
        return 1

    if copy_only:
        print("Script successfully copied",junos_image_name,"to /var/tmp/ directory of", device_address)
        router.close()
        return 0

    try:
        installation_status = sw.install(package="/var/tmp/"+junos_image_name,no_copy=True,progress=True,vmhost=is_vmhost_image,cleanfs=cleanfsflag,all_re=not(current_re_only))

        if installation_status:
                    print ("Rebooting",device_address, "after junos upgrade")
                    try:
                        sw.reboot(all_re=not(current_re_only),vmhost=is_vmhost_image)
                    except:
                        pass ## Pyez throws an exception after rebooting vmhost devices. This try-except block can be removed after it is fixed.
                    router.close()
                    wait_for_router_online(router,300)
                    router.open()
                    if str(dict(router.facts)['version']).strip('-EVO') == str(junos_version_for_upgrade):
                        print(device_address,"was successfully upgraded to",junos_version_for_upgrade)
                        return 0
                    else:
                        print("Script attempted upgrading",device_address,"to",junos_version_for_upgrade,"and rebooted the device. But current version is still not the target version.")
                        return 1
        else:
            print("Script could not complete installation of new junos image in ", device_address)
            router.close()
            return 1

    except Exception as e:
        print("Script could not complete installation of new junos image in ", device_address)
        print(str(e))
        router.close()
        return 1 

if __name__ == "__main__":
    execution_start_time = datetime.now()
    arg_parse= argparse.ArgumentParser()
    arg_parse.add_argument('--rsi',required=True,help='Mandatory: File path for RSI file',type=str)
    arg_parse.add_argument('--device',required=True,help='Mandatory: Name of device on which the config has to be loaded',type=str)
    arg_parse.add_argument('--username',help='Optional: Username to login to device',type=str)
    arg_parse.add_argument('--password',help='Optional: Password to login to device',type=str)
    arg_parse.add_argument('--version', action='version', version='%(prog)s '+script_version)
    arg_parse.add_argument('--config',default=str(sys.path[0])+'/adapt-rsi.yaml',help='Optional: Config file (yaml) for this script',type=str)
    arg_parse.add_argument('--noCommitConfirm',action='store_true',help='Optional: if specified, no commit confirmation has to be performed manually')
    arg_parse.add_argument('--upgrade',action='store_true',help='Optional: if specified, device will be upgraded to match the junos version in RSI')
    arg_parse.add_argument('--cleanfs',action='store_true',help='Optional: if specified, script will perform storage cleanup during junos upgrade')
    arg_parse.add_argument('--skipbaseline',action='store_true',help='Optional: if specified, script will not attempt to load baseline config')
    arg_parse.add_argument('--amazon',action='store_true',help='Optional: if specified, amazon specific config processing will be activated') ### activate experimental code to parse amazon scrubbed RSI
    arg_parse.add_argument('--timeout',default=30,type=int,help='Optional: if specified, the value will be used as the timeout for all RPC calls')
    args = arg_parse.parse_args()
    
    rsi_file=args.rsi
    router_name=''
    router_name_is_ip  = False
    router = None
    device_uname = ""
    device_passwd = ""
    set_personality(args.config)

    if Path(rsi_file).is_file():
        pass
    else:
        print("RSI file ",rsi_file," is not available. Script will now exit")
        sys.exit(1)

    if re.match(fqdn_regex,args.device):
        router_name=str(re.search(fqdn_regex,args.device).group(1))
    elif re.match('^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$',args.device):
        router_name=args.device
        router_name_is_ip = True
    else:
        router_name=args.device
    
    
    
    if args.username and args.password:
        device_uname = args.username 
        device_passwd = args.password
        if router_name_is_ip:
            router = Device (host=router_name,user=args.username,password=args.password,timeout=args.timeout)
        else:
            router = Device (host=router_name+fqdn_suffix,user=args.username,password=args.password,timeout=args.timeout)
        try:
            router.open()
        except ConnectAuthError:
            print ("Connection attempt to router failed because of authentication error. Please provide valid credentials.\n")
            sys.exit(1)
        except ConnectTimeoutError:
            print ("Connection attempt to router was timed out. Please make sure if the device is powered on and reachable from this server and whether netconf service via ssh is enabled on the device.\n")
            sys.exit(1)
        except ConnectError as err:
            print ("Cannot connect to device: {0}".format(err),"\n\nScript will now exit.")
            sys.exit(1)
    else:
        credentials_list_length = len(credentials_list)
        current_list_item = 1 
        for credential in credentials_list:
            if router_name_is_ip:
                router = Device (host=router_name,user=credential['username'],password=credential['password'],timeout=args.timeout)
            else:
                router = Device (host=router_name+fqdn_suffix,user=credential['username'],password=credential['password'],timeout=args.timeout)
            try:
                router.open()
                device_uname = credential['username']
                device_passwd = credential['password']
                break
            except ConnectAuthError:
                if credentials_list_length == current_list_item:
                    print("Could not connect to device using any credential mentioned in script config file. Script will now exit.\n")
                    sys.exit(1)
                else:    
                    current_list_item +=1
                    pass
            except ConnectTimeoutError:
                print ("Connection attempt to router was timed out. Please make sure if the device is powered on and reachable from this server and whether netconf service via ssh is enabled on the device.\n")
                sys.exit(1)
            except ConnectError as err:
                print ("Cannot connect to device: {0}".format(err),"\n\nScript will now exit.")
                sys.exit(1)
    
    
    
    if router.connected:
        router.close()

    if not args.skipbaseline:
        print ("\nScript will attempt to load config from ",rsi_file," to ",router_name,". Baseline config will be extracted from router and will be loaded before proceeding.\n")
        if load_baseline_config(router,router_name) != 0:
            print("\nScript Exiting. Failed to commit the baseline config on ",router_name,"\n")
            sys.exit(1)
    else:
        print ("\nScript will attempt to load config from ",rsi_file," to ",router_name,"\n")
    
    if args.upgrade:
        
        junos_version_from_rsi = None
        upgrade_status = 1

        with open(rsi_file) as input_data:
            junos_version_format1 = re.compile("^.*JUNOS\s*Base\s*OS\s*boot\s*\[(\S*)\].*$")
            junos_version_format2 = re.compile("^Junos:\s*(\S*)$")
            for line in input_data:
                if 'show version detail no-forwarding' in line.strip():
                    break
            for line in input_data:
                if junos_version_format1.match(line):
                    junos_version_from_rsi = junos_version_format1.search(line).group(1)
                    break
                elif junos_version_format2.match(line):
                    junos_version_from_rsi = junos_version_format2.search(line).group(1)
                    break
        
        if junos_version_from_rsi:
            if router_name_is_ip:
                upgrade_status = do_junos_upgrade(router,args.cleanfs,router_name,device_uname,device_passwd,junos_version_from_rsi.strip('-EVO'),False,False)
            else:
                upgrade_status = do_junos_upgrade(router,args.cleanfs,router_name+fqdn_suffix,device_uname,device_passwd,junos_version_from_rsi.strip('-EVO'),False,False)
        else:
            print("Could not fetch Junos version number from RSI file",rsi_file,"Script will now exit.")
            sys.exit(1)
        
        if upgrade_status !=0:
            print("Script could not upgrade",router_name,"to junos version",junos_version_from_rsi,"Conifg from RSI will not be loaded to the device.")
            sys.exit(1)

    try:
        
        if args.amazon: ### activate experimental code to parse amazon scrubbed RSI
            extract_modify_and_generate_config_for_amazon(router,rsi_file)
        else:
            extract_modify_and_generate_config(router,rsi_file)
        
        print("\nConfig Extraction from RSI completed successfully\n")

    except Exception as e:
            print(str(e))
            print("\nScript Exiting. Failed to extract config from RSI\n")
            sys.exit(1)
    

    if load_generated_config(router,router_name,args.noCommitConfirm) == 0:
        print("\nConfig extracted from RSI was committed successfully on ",router_name,"\n")
        execution_end_time = datetime.now()
        print("Script execution duration:",execution_end_time-execution_start_time)
    else:
        print("\nScript Exiting. Failed to commit the config extracted from RSI on ",router_name,"\n")
        execution_end_time = datetime.now()
        print("Script execution duration:",execution_end_time-execution_start_time)


    sys.exit(0)
