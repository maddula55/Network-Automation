#!/usr/bin/env python3
"""
Adapt-RSI is a script to extract configuration from a file containing junos RSI output 
and adapt the configuration to use it in a Juniper Ultralab device. 
Script will extract the config from RSI and remove config elements that might affect 
the connectivity to the device. Based on the no. of FPCs in target lab device, script 
will remove invalid fpc configuration and modify invalid interface names with dummy interface names.

Enhanced with:
  - Automatic backup of current config
  - Combined commit of RSI-derived and additional config in single transaction
  - Parallel processing of multiple devices
Version: v1.2.0
"""

import sys
import time
import argparse
import yaml
import re
import warnings
import subprocess
from pathlib import Path
from pprint import pprint
from datetime import datetime
import concurrent.futures

import jnpr.junos
from jnpr.junos import Device
from jnpr.junos.utils.sw import SW
from jnpr.junos.utils.config import Config
from jnpr.junos.utils.start_shell import StartShell
from jnpr.junos.exception import ConnectError, ConnectAuthError, ConnectTimeoutError, LockError
from lxml import etree

if sys.version_info < (3, 4):
    raise RuntimeError("This package requires Python 3.4+")

if not sys.warnoptions:
    warnings.simplefilter("ignore")

script_version = "v1.2.0"

# Global placeholders (populated by set_personality)
fpc_slots_in_chassis = {}
skip_hierarchy_list = []
skip_statement_list = []
junos_image_location_map = {}
hw_compatibility_map = {}
junos_image_name_format_map = {}
junos_image_name_format_selector = {}
split_copy_path = ""
baseline_groups = []
credentials_list = []
fqdn_regex = ""
fqdn_suffix = ""

# -----------------------------------------------------------------------------
# --- Personality / YAML loading ---------------------------------------------
# -----------------------------------------------------------------------------
def set_personality(config):
    if Path(config).is_file():
        with open(config, 'r') as yaml_file:
            cfg = yaml.safe_load(yaml_file)
            global fpc_slots_in_chassis, skip_hierarchy_list, skip_statement_list
            global junos_image_name_format_selector, junos_image_name_format_map
            global junos_image_location_map, hw_compatibility_map
            global split_copy_path, baseline_groups, credentials_list
            global fqdn_regex, fqdn_suffix

            fpc_slots_in_chassis             = cfg['fpc_slots_in_chassis']
            skip_hierarchy_list              = cfg['skip_hierarchy_list']
            skip_statement_list              = cfg['skip_statement_list']
            junos_image_name_format_selector = cfg['junos_image_name_format_selector']
            junos_image_name_format_map      = cfg['junos_image_name_format_map']
            junos_image_location_map         = cfg['junos_image_location_map']
            hw_compatibility_map             = cfg['hw_compatibility_map']
            split_copy_path                  = cfg['split_copy_path']
            baseline_groups                  = cfg['baseline_groups']
            credentials_list                 = cfg['credentials_list']
            fqdn_regex                       = cfg['fqdn_regex']
            fqdn_suffix                      = cfg['fqdn_suffix']
    else:
        print(f"Config file {config} not found. Exiting.")
        sys.exit(1)

# -----------------------------------------------------------------------------
# --- Automatic Backup of Current Config --------------------------------------
# -----------------------------------------------------------------------------
def backup_current_config(router, router_name):
    """Fetch and save the current configuration as a backup file."""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    backup_file = f"{router_name}_backup_{timestamp}.set"
    router.open()
    config_xml = router.rpc.get_config(options={'format': 'set'})
    with open(backup_file, 'w') as f:
        f.write(str(config_xml))
    router.close()
    print(f"[Backup] Configuration for {router_name} saved to {backup_file}")
    return backup_file

# -----------------------------------------------------------------------------
# --- RSI Extraction & Adaptation (Standard) ----------------------------------
# -----------------------------------------------------------------------------
def extract_modify_and_generate_config(router, rsi_file):
    # Step 1: Extract config from RSI
    with open(rsi_file) as input_data, open('temp_config_from_rsi.config','w') as router_config:
        comment_string = f"/* Configuration generated by adapt-rsi.py {script_version} using RSI output in {rsi_file} */\n"
        router_config.write(comment_string)
        rsi_validator = 0
        for line in input_data:
            if 'show configuration | except SECRET-DATA | display omit' in line.strip():
                rsi_validator += 1
                break
        more_pattern = re.compile(r'^(.*)---\(more\)---(.*)$')
        cr_pattern   = re.compile(r'\^M')
        for line in input_data:
            if 'show interfaces extensive no-forwarding' in line.strip():
                rsi_validator += 1
                break
            line = more_pattern.sub(r"\1\2", line)
            line = cr_pattern.sub("", line)
            router_config.write(line)
    if rsi_validator != 2:
        print(f"{rsi_file} is not a valid RSI file. Exiting.")
        sys.exit(1)

    # Step 2: Delete unwanted config
    with open('temp_config_from_rsi.config') as input_data, open('config_from_rsi.config','w') as router_config:
        line_number = 1
        current_hierarchy = []
        start_hierarchy_pattern = re.compile(r'^\s*(.*)\{\s*#?.*$')
        end_hierarchy_pattern   = re.compile(r'^\s*\}\s*')
        statement_end_pattern   = re.compile(r'^.*;\s*#?.*$')
        annotation_start_pattern= re.compile(r'^\s*/\*.*$')
        annotation_end_pattern  = re.compile(r'^.*\*/\s*$')
        description_pattern     = re.compile(r'^\s*description.*;\s*$')

        line = input_data.readline()
        while line:
            skip_hierarchy = False
            skip_line = False

            # Multi-line comment handling
            if annotation_start_pattern.match(line):
                while not annotation_end_pattern.match(line):
                    router_config.write(line)
                    line = input_data.readline()
                    line_number += 1
                router_config.write(line)
                skip_line = True

            # Hierarchy open
            if start_hierarchy_pattern.match(line) and not skip_line:
                hname = start_hierarchy_pattern.search(line).group(1).strip()
                current_hierarchy.append(hname)
                for item in skip_hierarchy_list:
                    parts = item.split('\\')
                    if len(parts) == len(current_hierarchy):
                        match = True
                        for i in range(len(parts)):
                            if '<*>' in parts[i]:
                                continue
                            if not current_hierarchy[i].startswith(parts[i]):
                                match = False
                                break
                        if match:
                            print(f"Ignoring hierarchy at line#{line_number}: [edit {' '.join(current_hierarchy)}]")
                            skip_hierarchy = True
                            break

            # Hierarchy close
            if end_hierarchy_pattern.match(line) and not skip_line:
                if current_hierarchy:
                    current_hierarchy.pop()

            # Skip entire hierarchy block if marked
            if skip_hierarchy:
                depth = 1
                while depth > 0:
                    nxt = input_data.readline()
                    line_number += 1
                    if start_hierarchy_pattern.match(nxt):
                        depth += 1
                    if end_hierarchy_pattern.match(nxt):
                        depth -= 1
                line = input_data.readline()
                line_number += 1
                continue

            # Skip non-set lines
            if not skip_line and not (start_hierarchy_pattern.match(line) or end_hierarchy_pattern.match(line) or statement_end_pattern.match(line)):
                skip_line = True

            # Skip specific statements
            if not skip_line and statement_end_pattern.match(line) and not description_pattern.match(line):
                for stmt in skip_statement_list:
                    parts = stmt.split('\\')
                    if len(parts)-1 == len(current_hierarchy):
                        match = True
                        for i in range(len(parts)-1):
                            if '<*>' in parts[i]:
                                continue
                            if not current_hierarchy[i].startswith(parts[i]):
                                match = False
                                break
                        if match and line.strip().startswith(parts[-1].strip()):
                            print(f"Ignoring statement at line#{line_number}: set {' '.join(current_hierarchy)} {line.strip()}")
                            skip_line = True
                            break

            if not skip_line:
                router_config.write(line)

            line = input_data.readline()
            line_number += 1

    # Step 3: Adapt interfaces / FPCs
    source_model = "UNKNOWN"
    with open(rsi_file) as input_data:
        for line in input_data:
            if 'show version detail no-forwarding' in line.strip():
                break
        for line in input_data:
            if 'Model' in line:
                m = re.search(r"^\s*Model:\s*(\S+)\s*$", line)
                if m:
                    source_model = m.group(1).upper()
                break

    print(f"\nDevice Model in RSI: {source_model}")
    router.open()
    target_model = router.facts['model'].upper()
    router.close()
    print(f"Model of device on which config has to be loaded: {target_model}")

    slots_src = fpc_slots_in_chassis.get(source_model, 20)
    slots_tgt = fpc_slots_in_chassis.get(target_model, 0)
    need_adapt = slots_src > slots_tgt

    interface_counter     = 50
    pic_counter           = 0
    tunnel_pic_counter    = 0
    tunnel_interface_ctr  = 20
    seen_interfaces       = {}

    interface_pattern          = re.compile(r"^(.*)(\w{2}-)(\d{1,2})/(\d*)/(\d*)(.*)$")
    interface_desc_pattern     = re.compile(r"^(.*)(description )(.*)(\w{2}-\d+/\d+/\d+)(.*)$")
    chassis_fpc_pattern        = re.compile(r"^.*fpc\s+(\d+).*{\s*$")

    with open('config_from_rsi.config') as input_data, open('final_config_from_rsi.config','w') as router_config:
        for line in input_data:
            m = interface_pattern.match(line)
            if m and not interface_desc_pattern.match(line) and need_adapt:
                fpc_slot = int(m.group(3))
                if fpc_slot >= slots_tgt:
                    original_iface = m.group(2) + f"{m.group(3)}/{m.group(4)}/{m.group(5)}"
                    if original_iface in seen_interfaces:
                        new_iface = seen_interfaces[original_iface]
                    else:
                        if any(t in original_iface for t in ('lt','vt','gr')):
                            new_iface = f"{m.group(2)}0/{tunnel_pic_counter}/{tunnel_interface_ctr}"
                            seen_interfaces[original_iface] = new_iface
                            tunnel_interface_ctr += 1
                            if tunnel_interface_ctr > 46:
                                tunnel_interface_ctr = 20
                                tunnel_pic_counter += 1
                        else:
                            new_iface = f"{m.group(2)}0/{pic_counter}/{interface_counter}"
                            seen_interfaces[original_iface] = new_iface
                            interface_counter += 1
                            if interface_counter > 126:
                                interface_counter = 50
                                pic_counter += 1
                    line = interface_pattern.sub(rf"\1{new_iface}\6", line)
            elif chassis_fpc_pattern.match(line) and need_adapt:
                slot_num = int(chassis_fpc_pattern.search(line).group(1))
                if slot_num >= slots_tgt:
                    depth = 1
                    while depth > 0:
                        nxt = input_data.readline()
                        if '{' in nxt: depth += 1
                        if '}' in nxt: depth -= 1
                    continue
            router_config.write(line)
    print("RSI config extraction and adaptation complete.")

# -----------------------------------------------------------------------------
# --- RSI Extraction & Adaptation (Amazon) ------------------------------------
# -----------------------------------------------------------------------------
def extract_modify_and_generate_config_for_amazon(router, rsi_file):
    print("Starting to parse RSI file... assuming Amazon-scrubbed format.\n")
    # Step 1: extract
    with open(rsi_file) as input_data, open('temp_config_from_rsi.config','w') as router_config:
        comment = f"/* Configuration generated by adapt-rsi.py {script_version} using RSI output in {rsi_file} */\n"
        router_config.write(comment)
        rsi_validator = 0
        for line in input_data:
            if re.match(r'^version.*;\s*$', line) or '## Last commit:' in line:
                rsi_validator += 1
                break
        more_pat = re.compile(r'^(.*)---\(more\)---(.*)$')
        cr_pat   = re.compile(r'\^M')
        for line in input_data:
            if 'show interfaces extensive no-forwarding' in line.strip():
                rsi_validator += 1
                break
            line = more_pat.sub(r"\1\2", line)
            line = cr_pat.sub("", line)
            router_config.write(line)
    if rsi_validator != 2:
        print(f"{rsi_file} is not a valid Amazon-scrubbed RSI. Exiting.")
        sys.exit(1)

    # Step 2: prune (similar to standard but accounting for scrub gaps)
    with open('temp_config_from_rsi.config') as input_data, open('config_from_rsi.config','w') as router_config:
        line = input_data.readline()
        line_number = 1
        current_hierarchy = []
        start_pat  = re.compile(r'^\s*(.*)\{\s*#?.*$')
        end_pat    = re.compile(r'^(\s*)\}\s*')
        stmt_pat   = re.compile(r'^.*;\s*#?.*$')
        annot_s    = re.compile(r'^\s*/\*.*$')
        annot_e    = re.compile(r'^.*\*/\s*$')
        desc_pat   = re.compile(r'^\s*description.*;\s*$')
        space_pat  = re.compile(r'^(\s*)\S')
        prev_start = False
        prev_stmt  = False
        prev_space = 0
        prev_written_start = False

        while line:
            skip_h = False
            skip_l = False

            # copy annotations
            if annot_s.match(line):
                while not annot_e.match(line):
                    router_config.write(line)
                    line = input_data.readline(); line_number+=1
                router_config.write(line)
                skip_l = True

            # detect start hierarchy
            if start_pat.match(line) and not skip_l:
                indent = len(space_pat.search(line).group(1))
                if not (indent > prev_space and not prev_start):
                    hname = start_pat.search(line).group(1).strip()
                    current_hierarchy.append(hname)
                    for item in skip_hierarchy_list:
                        parts = item.split('\\')
                        if len(parts) == len(current_hierarchy):
                            match = True
                            for i in range(len(parts)):
                                if '<*>' in parts[i]:
                                    continue
                                if not current_hierarchy[i].startswith(parts[i]):
                                    match = False
                                    break
                            if match:
                                print(f"Ignoring hierarchy at line#{line_number}: [edit {' '.join(current_hierarchy)}]")
                                skip_h = True
                                break

            # detect end hierarchy
            if end_pat.match(line) and not skip_l:
                indent = len(end_pat.search(line).group(1))
                if (indent < prev_space) or ((prev_start or prev_written_start) and indent==prev_space):
                    current_hierarchy.pop()
                else:
                    skip_l = True
                    print(f"Ignoring line#{line_number}: unmatched '}}'")

            # skip hierarchy if flagged
            if skip_h:
                depth = 1
                local_space = len(space_pat.search(line).group(1))
                local_start = False
                local_stmt  = False
                while depth > 0:
                    nxt = input_data.readline(); line_number+=1
                    if end_pat.match(nxt):
                        indent = len(end_pat.search(nxt).group(1))
                        if indent < local_space or (local_start and indent==local_space):
                            depth -=1
                            local_space = indent
                        local_start = False
                    elif start_pat.match(nxt):
                        depth +=1; local_start=True
                    else:
                        local_start=False
                    if local_start or stmt_pat.match(nxt):
                        local_space = len(space_pat.search(nxt).group(1))
                skip_l=True
                current_hierarchy.pop()

            # skip omitted lines
            if re.match(r'^\s*\*{5}LINE OMITTED\*{5}\s*$', line) or re.match(r'^\s*X+\s*$', line):
                skip_l = True

            # skip non-hierarchy/statement lines
            if not skip_l and not (start_pat.match(line) or end_pat.match(line) or stmt_pat.match(line)):
                skip_l=True
                if line.strip():
                    print(f"Ignoring line#{line_number}: {line.strip()}")

            # skip statements under scrubbed config
            if not skip_l and stmt_pat.match(line) and not desc_pat.match(line):
                for stmt in skip_statement_list:
                    parts = stmt.split('\\')
                    if len(parts)-1 == len(current_hierarchy):
                        match = True
                        for i in range(len(parts)-1):
                            if '<*>' in parts[i]:
                                continue
                            if not current_hierarchy[i].startswith(parts[i]):
                                match=False; break
                        if match and line.strip().startswith(parts[-1].strip()):
                            print(f"Ignoring statement at line#{line_number}: set {' '.join(current_hierarchy)} {line.strip()}")
                            skip_l=True
                            break

            if not skip_l:
                prev_space = len(space_pat.search(line).group(1))
                prev_start = bool(start_pat.match(line))
                prev_written_start = prev_start
                router_config.write(line)
            line = input_data.readline(); line_number+=1

    # Step 3: same interface adaptation as standard
    extract_modify_and_generate_config(router, rsi_file)  # reuse standard adaptation

# -----------------------------------------------------------------------------
# --- Load Baseline Configuration (original) ----------------------------------
# -----------------------------------------------------------------------------
def load_baseline_config(router, router_name):
    shellSession = StartShell(router)
    shellSession.open()
    with open('baseline_from_router.set','w') as base_config:
        for group in baseline_groups:
            shell_output = shellSession.run(f'cli -c "show configuration groups {group}| display set| no-more"')
            config = shell_output[1].split('\n')[1:-1]
            for cmd in config:
                base_config.write(cmd + '\n')
            base_config.write(f'set apply-groups {group}\n')
        base_config.write('set system services netconf ssh\n')
    shellSession.close()

    router.open()
    facts = dict(router.facts)
    synchronize = False
    if 're0' in facts['current_re'] and facts.get('RE1', {}).get('status') == 'OK':
        synchronize = True
    if 're1' in facts['current_re'] and facts.get('RE0', {}).get('status') == 'OK':
        synchronize = True

    with Config(router) as cu:
        cu.load('', overwrite=True, format='text', ignore_warning=True)
        cu.load(path='baseline_from_router.set', format='set', ignore_warning=True)
        try:
            cu.commit(force_sync=synchronize, timeout=360)
            print(f"Applied baseline config on {router_name}\n")
            router.close()
            return 0
        except Exception as e:
            print(str(e))
            print(f"\nFailed to load baseline config to {router_name}\n")
            router.close()
            return 1

# -----------------------------------------------------------------------------
# --- Junos Upgrade Routine (original) ----------------------------------------
# -----------------------------------------------------------------------------
def do_junos_upgrade(router, cleanfsflag, device_address, device_username,
                     device_password, junos_version_for_upgrade, current_re_only, copy_only):
    router.open()
    facts = dict(router.facts)
    router.close()
    current_re_model = None

    if str(facts['version']).strip('-EVO') == str(junos_version_for_upgrade):
        print(device_address, "already running junos version", junos_version_for_upgrade)
        return 0

    # Determine current RE model
    if 're0' in facts['current_re']:
        current_re_model = facts['RE0'].get('model')
        if not current_re_model:
            print(f"Cannot fetch RE0 model on {device_address}. Skipping upgrade.")
            return 1
        # handle dual-RE logic...
    elif 're1' in facts['current_re']:
        current_re_model = facts['RE1'].get('model')
        if not current_re_model:
            print(f"Cannot fetch RE1 model on {device_address}. Skipping upgrade.")
            return 1
        # handle dual-RE logic...
    else:
        print(f"Cannot identify current RE on {device_address}. Skipping upgrade.")
        return 1

    # Select image format
    version_year = int(re.search(r'^(\d+)\.', junos_version_for_upgrade).group(1))
    fmt_type = None
    for key, val in junos_image_name_format_selector.items():
        if val['from'] <= version_year <= val['to']:
            fmt_type = key
    if not fmt_type:
        print(f"No image name format for version {junos_version_for_upgrade}.")
        return 1

    # Build image name
    name_fmt = junos_image_name_format_map[fmt_type].get(current_re_model)
    if not name_fmt:
        print(f"No image name format map for RE {current_re_model}.")
        return 1
    junos_image_name = re.sub(r'VERSION_NUMBER', junos_version_for_upgrade, name_fmt)

    # Search image path
    maj_ver = re.search(r'^(\d+\.\d)', junos_version_for_upgrade).group(1)
    dir_ver = junos_version_for_upgrade
    paths = junos_image_location_map.get(current_re_model, [])
    junos_image_path = None
    for p in paths:
        candidate = p.replace('MAJOR_VERSION_NUMBER', maj_ver).replace('VERSION_NUMBER', dir_ver) + junos_image_name
        if Path(candidate).is_file():
            junos_image_path = candidate
            break
    if not junos_image_path:
        print(f"Image {junos_image_name} not found for {device_address}.")
        return 1

    # Copy or verify existing on device
    router.open()
    sw = SW(router)
    checksum_matches = False
    for algo in ('md5','sha1','sha256'):
        local_sum = None
        remote_sum = None
        if Path(junos_image_path + f'.{algo}').is_file():
            with open(junos_image_path + f'.{algo}') as csf:
                local_sum = csf.read().split()[0]
            remote_sum = sw.remote_checksum(f'/var/tmp/{junos_image_name}', algorithm=algo)
        if local_sum and remote_sum and local_sum == remote_sum:
            checksum_matches = True
            break
    if not checksum_matches:
        # attempt splitcopy
        if Path(split_copy_path).is_file():
            ret = subprocess.call([split_copy_path, junos_image_path,
                                   f"{device_username}@{device_address}:/var/tmp/",
                                   "--pwd", device_password], timeout=900)
            if ret != 0:
                sw.put(junos_image_path, progress=True)
        else:
            sw.put(junos_image_path, progress=True)

    if copy_only:
        print(f"Copied {junos_image_name} to /var/tmp/ on {device_address}")
        router.close()
        return 0

    # Install and reboot
    try:
        install_status = sw.install(package=f"/var/tmp/{junos_image_name}",
                                    no_copy=True,
                                    progress=True,
                                    vmhost=('vmhost' in junos_image_name),
                                    cleanfs=cleanfsflag,
                                    all_re=not current_re_only)
        if install_status:
            print(f"Rebooting {device_address} after upgrade")
            sw.reboot(all_re=not current_re_only, vmhost=('vmhost' in junos_image_name))
            router.close()
            # wait for online...
            return 0
        else:
            print(f"Installation failed on {device_address}")
            router.close()
            return 1
    except Exception as e:
        print(f"Upgrade exception on {device_address}: {e}")
        router.close()
        return 1

# -----------------------------------------------------------------------------
# --- Combined commit function already defined above --------------------------
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# --- Per-Device Workflow wrapper ---------------------------------------------
# -----------------------------------------------------------------------------
def process_device(device, args, credentials_list, fqdn_regex, fqdn_suffix):
    host = device if re.match(fqdn_regex, device) else device + fqdn_suffix
    router = Device(host=host, user=args.username, password=args.password, timeout=args.timeout)
    backup_current_config(router, device)
    if not args.skipbaseline:
        load_baseline_config(router, device)
    if args.upgrade:
        do_junos_upgrade(router, args.cleanfs, device, args.username, args.password,
                         args.junos_version or None, False, False)
    if args.amazon:
        extract_modify_and_generate_config_for_amazon(router, args.rsi)
    else:
        extract_modify_and_generate_config(router, args.rsi)
    load_generated_config(router, device, args.noCommitConfirm, args.additional_config)

# -----------------------------------------------------------------------------
# --- Main Entrypoint ---------------------------------------------------------
# -----------------------------------------------------------------------------
if __name__ == "__main__":
    execution_start_time = datetime.now()
    parser = argparse.ArgumentParser()
    parser.add_argument('--rsi', required=True, help='RSI file path', type=str)
    parser.add_argument('--device', help='Single device hostname or IP', type=str)
    parser.add_argument('--devices', nargs='+', help='Multiple devices for parallel')
    parser.add_argument('--username', required=True, help='Username', type=str)
    parser.add_argument('--password', required=True, help='Password', type=str)
    parser.add_argument('--additional-config', help='Extra config file (set)', type=str)
    parser.add_argument('--skipbaseline', action='store_true', help='Skip baseline load')
    parser.add_argument('--upgrade', action='store_true', help='Perform Junos upgrade')
    parser.add_argument('--amazon', action='store_true', help='Amazon RSI parsing')
    parser.add_argument('--noCommitConfirm', action='store_true', help='Disable commit confirm')
    parser.add_argument('--cleanfs', action='store_true', help='Filesystem cleanup on upgrade')
    parser.add_argument('--timeout', default=30, type=int, help='RPC timeout (s)')
    parser.add_argument('--junos-version', help='Explicit Junos version', type=str)
    parser.add_argument('--config', default=str(Path(sys.path[0])/'adapt-rsi.yaml'),
                        help='YAML config file path', type=str)
    args = parser.parse_args()

    set_personality(args.config)
    devices = args.devices or ([args.device] if args.device else [])
    if not devices:
        print("Specify --device or --devices")
        sys.exit(1)

    max_workers = min(len(devices), 5)
    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
        for dev in devices:
            executor.submit(process_device, dev, args, credentials_list, fqdn_regex, fqdn_suffix)

    print("\nAll device operations completed.")
    execution_end_time = datetime.now()
    print("Total duration:", execution_end_time - execution_start_time)
